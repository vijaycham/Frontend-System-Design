# REST API Notes

## 1. Overview
- What is REST API?
- Why REST? Benefits

## 2. Building Blocks
- URL / Endpoint
- HTTP Methods (GET, POST, PUT, DELETE, PATCH)
- Headers
- Request Body
- Response Body
- Status Codes

## 3. Building a Simple App
- Steps to create a REST API
- Example with Node.js / Express
- Testing with Postman

## 4. HTTP Versions
- HTTP/1.1 vs HTTP/2 vs HTTP/3
- Features and differences

## 5. Best Practices
- RESTful design rules
- Versioning
- Error handling
- Pagination & filtering
- Security (Authentication & Authorization)

## 6. Advanced Concepts
- Statelessness & caching
- Rate limiting
- HATEOAS (Hypermedia as the Engine of Application State)
- API Documentation (Swagger / OpenAPI)

---

# REST API Communication

## 1. What is REST API?

- **Communication Required:** Whenever client (UI) and server (kitchen) need to talk, we use an API.
- **REST API** is the most commonly used API standard.

### Breakdown of REST API:
- **REST:** Representational State Transfer â†’ defines a set of rules/conventions to communicate between systems.
- **API:** Application Programming Interface â†’ allows different programs to talk to each other.

### Analogy:
- Kitchen (backend) prepares food â†’ Eating area (frontend) receives it.
- Different APIs exist: REST, GraphQL, gRPC, etc.
- REST is like a **standardized waiter**:
  - Waiter follows a **set path** from kitchen to hall.
  - Doesnâ€™t go randomly, doesnâ€™t waste time.
  - Ensures food (data) reaches the correct table (client) in an organized manner.

### How It Works:
- **HTTP (Hypertext Transfer Protocol):** The path and foundation for the communication.
- REST API defines **standards, rules, and conventions** to:
  - Order data requests.
  - Deliver responses.
  - Ensure client and server communicate efficiently and predictably.

### Proper Definition:
**REST API** is an architectural style for designing networked applications that allows clients and servers to communicate over HTTP by following a set of conventions for structuring requests and responses, ensuring stateless, scalable, and standardized communication.

---

# REST API Benefits

## 1. Benefits of Using REST API

- **Ease of Use:** Simple, standardized methods make APIs easy to understand and implement.  
  *Analogy:* Waiter has a clear path and menu, easy to follow.  

- **Statelessness:** Each request from client contains all information needed; server does not store session info.  
  *Analogy:* Waiter doesnâ€™t remember previous orders; each order is independent.  

- **Scalability:** Stateless architecture allows servers to handle more clients easily.  
  *Analogy:* More waiters can handle more tables without confusion.  

- **Flexibility with Data:** Supports multiple formats like JSON, XML, HTML.  
  *Analogy:* Kitchen can pack food in different containers for different tables.  

- **Uniform Interface:** Standardized rules for request/response.  
  *Analogy:* Waiter always follows same steps to deliver food, reduces errors.  

- **Caching:** Responses can be cached to improve performance.  
  *Analogy:* Frequently ordered dishes can be pre-prepared to serve faster.  

- **Separation of Concerns:** Client and server are independent.  
  *Analogy:* Eating area and kitchen work independently; changes in kitchen donâ€™t break frontend.  

- **Interoperability (Language Agnostic):** Any client can communicate with server regardless of technology.  
  *Analogy:* Waiter can deliver food to different types of customers without issues.  

- **Ease of Testing:** Standardized endpoints make testing straightforward.  

- **Security:** Can implement authentication, authorization, HTTPS, and other security measures.  

### 2. Experimentation
- Use **dummy APIs** to practice: [https://dummyjson.com](https://dummyjson.com)  
  - Fetch data, test endpoints, experiment with GET, POST, PUT, DELETE.

---

# REST API Building Blocks

## 1. HTTP Request and Response Model

When the client (Frontend/UI) communicates with the server (Backend), the communication happens through **HTTP messages**.  
These are of two types: **Request** and **Response**.

---

### ðŸ“¨ HTTP Request
When the client asks for something (like food order to kitchen).

A typical HTTP Request contains:

1. **Request Line**  
   - Contains **HTTP Method**, **URL/Endpoint**, and **HTTP Version**.  
   - Example:  
     ```
     GET /products HTTP/1.1
     ```

2. **Headers**  
   - Contain metadata about the request (like authentication, content type, etc.)  
   - Example:  
     ```
     Content-Type: application/json
     Authorization: Bearer <token>
     ```

3. **Body (Optional)**  
   - Contains data to be sent to the server.  
   - Example (for POST/PUT):  
     ```json
     {
       "name": "Burger",
       "price": 120
     }
     ```

*Analogy:*  
Client = Customer placing order  
Waiter = API  
Request = Customer telling waiter what they want + special instructions (headers/body)

---

### ðŸ“¦ HTTP Response
When the server replies (kitchen sending prepared dish back).

A typical HTTP Response contains:

1. **Status Line**  
   - Contains **HTTP Version**, **Status Code**, and **Status Message**.  
   - Example:  
     ```
     HTTP/1.1 200 OK
     ```

2. **Headers**  
   - Additional information (like content type, caching policy).  
   - Example:  
     ```
     Content-Type: application/json
     ```

3. **Body**  
   - Actual data returned from the server.  
   - Example:  
     ```json
     {
       "id": 1,
       "name": "Burger",
       "price": 120
     }
     ```

*Analogy:*  
Response = Waiter bringing food (data) from kitchen to customer (client) with details (headers).

---

### 2. Basic Flow Example
```plaintext
Client (Browser / Postman)  â†’  sends HTTP Request  â†’  Server (Express.js)
Server processes request â†’  sends HTTP Response  â†’  Client receives data

