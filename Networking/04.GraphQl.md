# Table of Contents
1. [GraphQL Overview](#graphql-overview-easy-understanding)
2. [Apollo Sandbox](#apollo-graphql-sandbox-understanding)
3. [GraphQL Benefits](#graphql-benefits)
4. [REST vs GraphQL](#rest-vs-graphql--differences)
5. [GraphQL Architecture](#graphql-architecture--high-level)
6. [Schema & Types](#graphql-schema--types-deep-basics)
7. [Queries, Mutations, Resolvers](#graphql-queries-mutations--resolvers-deep-basics)
8. [Missing Core Concepts](#additional-core-graphql-definitions)



# GraphQL Overview 

## 1. Why GraphQL? — The Problem with REST

Imagine you want to fetch:
- All continents
- Their countries
- And each country’s languages

### REST Approach
You would usually need multiple endpoints:
```
GET /api/continents
GET /api/countries
GET /api/languages
```
This means:
- 3 different network requests
- You get full data, even the fields you don’t need
- Client cannot control the shape of the response (Server decides everything)

Example: `/countries` will return all country fields:
- name
- code
- capital
- population
- currencies
- languages
- borders

Even if you only needed country names → **over-fetching**.

If `/continents` doesn’t include countries list → need another call → **under-fetching**.

---
## 2. GraphQL Solves This Problem
GraphQL uses **one endpoint**:
```
/graphql
```
And the client can ask **exactly** the data it wants.

### Example GraphQL Query
```graphql
{
  continents {
    name
    countries {
      name
      languages {
        name
      }
    }
  }
}
```
With **ONE request**, the client gets:
- only `continent.name`
- only `country.name`
- only `language.name`

Nothing extra. No multiple endpoints.

---
## 3. Why GraphQL for Complex Relationships?
GraphQL works best when data is naturally connected like a **graph**:
- Continent → Countries → Languages
- Users → Friends → Posts → Comments

### Example
```graphql
{
  user(id: 1) {
    name
    friends {
      name
      posts {
        title
      }
    }
  }
}
```
REST = multiple calls
GraphQL = one request

---
## 4. Why the Name "GraphQL"?
- **Graph** → Data connected like nodes & edges
- **QL** → Query Language (like SQL but nested)

So: **Graph Query Language**.

---
## 5. History of GraphQL
- **2012:** Facebook created it for the News Feed
- **2015:** Open-sourced
- Adopted by GitHub, Shopify, Netflix, PayPal, Airbnb

---
## 6. Summary
- REST → many endpoints
- GraphQL → one endpoint
- REST → returns all data
- GraphQL → returns only requested data
- Perfect for nested/related data structures

---
# Apollo GraphQL Sandbox (Understanding)

## 1. What is Apollo Sandbox?
- A dashboard/playground for GraphQL
- Similar to Postman but specifically for GraphQL
- Supports queries, mutations, realtime response preview

## 2. Key Features
### ✔ Single Request for Required Data
```graphql
{
  users {
    name
    email
  }
}
```

### ✔ Auto-Suggestion
Suggests:
- types
- fields
- arguments

### ✔ GraphQL-Optimized Playground
- Single endpoint
- Nested queries
- Explorer panel
- Schema lookup

### ✔ Intro-Level Demo
Teacher didn’t cover advanced:
- SDL
- Resolvers
- Apollo Client caching

---
## 3. Summary
- Apollo Sandbox = powerful GraphQL testing tool
- Autocomplete works because schema is strongly typed
- Best for exploring queries & mutations

---
# GraphQL Benefits

## 1. Avoid Over-Fetching
REST returns more data than needed. GraphQL returns exactly what client asks.

## 2. Avoid Under-Fetching
REST may require multiple calls. GraphQL fetches nested data in one query.

## 3. Better Mobile Performance
Fetch only minimal data → less battery, data usage.

## 4. Efficiency & Precision
Client defines required data → no waste.

## 5. Declarative Data Fetching
Client declares shape of response.

## 6. Structural / Hierarchical Fetching
GraphQL matches real-world nested structures.

## 7. Strongly Typed
Schema defines everything clearly.

## 8. Introspection
GraphQL can describe itself → documentation auto-generated.

## 9. Real-Time (Subscriptions)
Supports realtime features via WebSockets.

## 10. Works on HTTP
Still uses HTTPS, POST, headers.

---
# REST vs GraphQL — Differences

## Table Summary
| Aspect | REST | GraphQL |
|--------|------|----------|
| Endpoints | Multiple | Single (`/graphql`) |
| Structure | Fixed, uses HTTP methods | Flexible, Query/Mutation |
| Over-Fetching | Yes | No |
| Under-Fetching | Yes | No |
| Response Size | Fixed | Flexible |
| Versioning | `/v1`, `/v2` | Rarely needed |
| Schema | None | Strongly typed SDL |
| Documentation | Separate | Built-in introspection |
| Real-Time | Polling/WebSockets | Subscriptions |
| Tooling | Postman | Apollo/GraphiQL |
| Caching | HTTP cache | Apollo/Relay cache |
| Client Control | Low | High |
| Nested Data | Hard | Easy |

---
# GraphQL Architecture — High-Level

## 1. Creator vs Consumer
### Creator (Server)
Defines:
- Schema
- Types
- Query & Mutation
- Resolvers

Uses server libraries:
- Apollo Server
- Express-GraphQL
- GraphQL Yoga
- Mercurius

### Consumer (Client)
Fetch using:
- Basic fetch
- Apollo Client / Relay / URQL

---
# Core Terms (Building Blocks)

## 1. Schema
Defines fields, types, relations.
Written in SDL.

## 2. Types
Examples:
- `type User`
- `type Country`
- `type Continent`

## 3. Query
Used to **read** data.

## 4. Mutation
Used to **write/update/delete** data.

## 5. Resolver
Function that returns data.
```js
(parent, args, context, info)
```

---
# GraphQL Schema & Types (Deep Basics)

## 1. Schema Definition
Example:
```graphql
type Country {
  code: String
  currency: String
  phone: String
  id: ID
}
```

## 2. Scalar Types
- String
- Int
- Float
- Boolean
- ID

## 3. Custom Object Types
Example:
```graphql
type Continent {
  name: String
  countries: [Country]
}
```

## 4. SDL (Schema Definition Language)
Defines types, fields, relationships.

---
# Queries, Mutations & Resolvers

## Query (Read)
```graphql
type Query {
  countries: [Country]
}
```

## Mutation (Write)
```graphql
type Mutation {
  updateLanguage(id: ID): Language
}
```

## Resolver Example
```js
const resolvers = {
  Query: {
    countries: (parent, args, context) => context.db.countries
  }
}
```

---
# Summary
- Query = Read
- Mutation = Write
- Resolver = Actual logic
- Schema = Blueprint
- SDL = Defines structure   

---
# Additional Core GraphQL Definitions

## 1. Root Types
| Root Type | Purpose |
|-----------|---------|
| **Query** | Entry point for READ operations |
| **Mutation** | Entry point for WRITE operations |
| **Subscription** | Entry point for REAL‑TIME operations |

These are the **main entry points** of the entire schema.

---
## 2. Fields
A **field** is the smallest unit of GraphQL data.
- Every field has a type.
- Every field can have a resolver.

Example:
```graphql
user {
  name
  age
}
```

---
## 3. Arguments
Arguments allow clients to send input to fields.

Example:
```graphql
user(id: ID!): User
```

---
## 4. Non-Null (!) and List ([]) Types
| Syntax | Meaning |
|--------|---------|
| `String` | Optional string |
| `String!` | Required string |
| `[User]` | List of users (optional) |
| `[User]!` | Required list of users |
| `[User!]!` | Required list of required users |

---
## 5. Resolver Parameters (Formal Definitions)
| Parameter | Meaning |
|-----------|---------|
| **parent** | Result from previous resolver in nesting |
| **args** | Arguments passed by client |
| **context** | Shared object: DB, auth, loaders |
| **info** | Internal query details |

---
## 6. Input Types
Used to send structured input to mutations.

```graphql
input AddUserInput {
  name: String!
  age: Int
}
```

---
## 7. Enums
Used for fixed choices.

```graphql
enum Role {
  USER
  ADMIN
}
```

---
## 8. Interfaces
Used for shared fields across types.

```graphql
interface Character {
  name: String!
}
```

---
## 9. Unions
Returns different types.

```graphql
union SearchResult = User | Product
```

---
## 10. What is a Graph (in GraphQL)?
Data is interconnected like:
- Nodes (entities)
- Edges (relationships)

GraphQL is efficient because **queries follow these graph relationships naturally**.

---
## 11. Apollo Client (Definition)
A powerful frontend GraphQL client that provides:
- Caching
- Request deduplication
- Auto updates
- Error handling
- State management

---
## 12. Apollo Server (Definition)
A GraphQL server implementation that:
- Builds schema
- Handles queries & mutations
- Integrates with resolvers
- Supports subscriptions

---
## 13. Schema Stitching
Combines multiple schemas into one.

---
## 14. Federation
Used to build large-scale distributed GraphQL systems.
Allows different services to own different parts of a unified schema.

---
# End of Notes
